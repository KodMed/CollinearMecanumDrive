/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * inertial_pos_control_ddxr_ddyr_ddphir_fun.c
 *
 * Code generation for function 'inertial_pos_control_ddxr_ddyr_ddphir_fun'
 *
 */

/* Include files */
#include "inertial_pos_control_ddxr_ddyr_ddphir_fun.h"
#include "mwmathutil.h"
#include "rt_nonfinite.h"

/* Function Definitions */
void inertial_pos_control_ddxr_ddyr_ddphir_fun(const emlrtStack *sp, const
  real_T in1[8], real_T K_vr, real_T K_p, real_T K_dphir, real_T K_phi, real_T
  v_max, real_T dphi_max, real_T dxr, real_T dyr, real_T dphir, real_T xr,
  real_T yr, real_T phir, real_T K_slow, real_T *ddxr, real_T *ddyr, real_T
  *ddphir)
{
  real_T t2;
  real_T t3;
  real_T a;
  (void)sp;

  /* INERTIAL_POS_CONTROL_DDXR_DDYR_DDPHIR_FUN */
  /*     [DDXR,DDYR,DDPHIR] = INERTIAL_POS_CONTROL_DDXR_DDYR_DDPHIR_FUN(IN1,K_VR,K_P,K_DPHIR,K_PHI,V_MAX,DPHI_MAX,DXR,DYR,DPHIR,XR,YR,PHIR,K_SLOW) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     07-Jun-2020 14:23:28 */
  t2 = muDoubleScalarCos(in1[2]);
  t3 = muDoubleScalarSin(in1[2]);
  a = (dxr * dxr + dyr * dyr) + -(v_max * v_max);
  a = K_p * (a * a);
  *ddxr = -muDoubleScalarExp(-K_slow * muDoubleScalarAbs((dxr - in1[4] * t2) +
    in1[5] * t3)) * (K_vr * dxr + a * (in1[0] - xr));
  *ddyr = -muDoubleScalarExp(-K_slow * muDoubleScalarAbs((-dyr + in1[4] * t3) +
    in1[5] * t2)) * (K_vr * dyr + a * (in1[1] - yr));
  a = dphir * dphir - dphi_max * dphi_max;
  *ddphir = -muDoubleScalarExp(-K_slow * muDoubleScalarAbs(dphir - in1[6])) *
    (K_dphir * dphir - K_phi * (a * a) * (phir - in1[2]));
}

/* End of code generation (inertial_pos_control_ddxr_ddyr_ddphir_fun.c) */
